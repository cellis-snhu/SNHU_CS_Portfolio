# SNHU_CS

# CS250 Essential Questions

## How do I interpret user needs and implement them into a program? How does creating “user stories” help with this?

Often users attempt to ask for what they *think* they want, but they are not usually intimately familiar with the underlying pieces of technology that they are asking in relation to. In response to this, developers and other techincal staff must learn to interpret what users are actually asking for, and determine how to take that request and implement it in a reasonable way inside the system or program they are working on. 

Computational operations at their base are actually very simple, programs generally being a larger abstraction of this idea, but functionally all take some data, transform it, and output it. Outputs can be text, or units of work performed on another data, or interaction with systems and people in the real world. Taking this idea, we can work backwards by determining what output is the user looking to receive, determining what input interaction the user can do with what they know, and then having the function or program translate input to output.

User stories help codify this into simple questions or prompts a non-technical person can answer, those generally being translated to some formulation of:

As a $user, I want to $do_something, so that I can $see_result.

As you can see, user stories map very closely to the formulation of a program, where the action a user wants to perform is the 'input', and the why of that being the output or result. The transformation of that input to desired output is generally the domain of the developer to implement how they see fit with the guidelines their oganization has for software development.


## How do I approach developing programs? What agile processes do I hope to incorporate into my future development work?

I personally, when possible, prefer to approach writing programs with a method similar to test driven development (TDD). My background in infrastructure often leads me down a similar path to designing anything, as I often know what the end result should be doing, in which case it only makes sense to *prove* that outcome with things like tests, automated policy checks, or security scans.

I often chase simplicity, and I understand that sometimes you need a big hunk of marble before you can carve it down into the perfect sculpture. In this vein, also very well aligned with TDD, I attempt to approach most of my work by making small changes, or in the case of greenfield projects making tiny prototypes to prove the concept can work before delving into the work of building a large program.

## What does it mean to be a good team member in software development?

I think the most important trait in a team member is a strangely self-evident one that many people haven't actually considered when they look at how they interact with others, that being that you understand that the point of teamwork is to do things a single person can't, and everything you're doing is really in service of that goal.

I believe looking at teamwork with this lens helps get rid of some of the ego around working in a team, and organizations should praise and incentivize this behavior when they see it.
